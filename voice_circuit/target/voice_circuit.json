{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":3702718277076930017,"abi":{"parameters":[{"name":"voice_embedding","type":{"kind":"array","length":256,"type":{"kind":"field"}},"visibility":"private"},{"name":"command_hash","type":{"kind":"field"},"visibility":"private"},{"name":"voice_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"expected_command_hash","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+2dBZBdyZGuq9UtZmZmbgYxMzNLjWJmZmZmZmZmZmZmZqaR9LJjS3Yeebx27MmsiDqvFJE7eWfWNfn3/fx/Y3YR//Pre2Qhfrj9zy5/I1zEv/76/fsKyd+62/vlQfiWewR0p6s81O3PEK6MAbzcfb29Q/08Qz28PALdPQOC/H3cvX2CfP09/D18/H1CPP29vEL9vf39AoIC/NwDPLy9Qj3CfAK8wuRj4Uf/l28F/4e3PNxc6H6wKoFwETxARJSHRuIGwoUQiIiEQEQiBCI8YxSYqOjn+I+3/b1C/QI8PEL8vXzcA/x8PQPgAl8/Hy+PsGAPn+DAsBC/gED/gKDQ0OAgr4AAd68w3wAfP89gXy/fMO9An8Cff7znEegX5hMaFhgY4hfmBQ94+gQGePiHebkHB/uH+Hl5eYUFBwcG+cEfDg5wD/PwDgn19wgKDvbx9A8LCPDyCflJ+/26/wvwPt6Bgf6+gX5ewUH+gV7ePp4+oT5BQaEhvqHeXkGBHh4B/qH+vu5hPmFeAT7unr7+YX4eIWHePgEeQSGh3u6ef97n6R4QEhwWFOYJ/8fHLywgzNfdG34y3iF+HoHBvmGBYf5+nvCnDAv283b3C3b3Dg3y9fQI9PX09wsODPbw9OXO6xkS5h8U4O0e6uMf4B7qDTj6+YW6+3j5eYUFhvoGBHqE+Pl4w3fq5RMKPxR/9yBfX98Abz9v+P49g0OC/+X78AwNDvH3D/HwCfD1Cwr28Qry94efjWeoe4iHr7+vrwdkDQ7yDQwM9gzxCvP3CfWEnH6hoWFBnsEeAQAbR95I8q3wPbyUf8rdDe0R0R5J7oR3eFLnCn8vMtwZBSaqi1rLR3bhKfVo8tDo3KUe2YWu1KMRlnp0TS0fQfAAEUMeGpMbCBzALhAxCIGIaSxPlt3ynrG8oy0fDdk8OtpjoD2mJpaPBXfGhomj2PKxmCwfVx4aj7vUYxFaPi5hqcfT1PKuggeI+PLQBNxA4AB2gYhPCEQCY3my7Jb3jOUdbfm4yObx0B4f7Qk0sXxCuDMRTGLFlk/IZPkk8tCk3KWekNDySQhLPammlncTPEAkk4cm5wYCB7ALRDJCIJIby5Nlt7xnLO9oyydBNk+K9mRoT66J5VPAnSlhUim2fAomy6eWh6bhLvUUhJZPTVjqaTS1fETBA0RaeWg6biBwALtApCUEIp2xPFl2y3vG8o62fGpk8zRoT4v2dJpYPj3cmQEmo2LLp2eyfCZ5aGbuUk9PaPlMhKWeWVPLRxI8QGSRh2blBgIHsAtEFkIgshrLk2W3vGcs72jLZ0I2z4z2LGjPqonls8Gd2WFyKLZ8NibL55SH5uIu9WyEls9JWOq5NLV8ZMEDRG55qDs3EDiAXSByEwLhbixPlt3ynrG8oy2fE9k8F9pzo91dE8uH/weAPGG8FFveg8ny3vJQH+5S9yC0vDdhqftoavkoggcIX3moHzcQOIBdIHwJgfAzlifLbnnPWN7RlvdGNvdBuy/a/TSxvD/cGQCTR7Hl/Zksn1cemo+71P0JLZ+XsNTzaWr5qIIHiPzy0ALcQOAAdoHITwhEAWN5suyW94zlHW35vMjm+dCeH+0FNLF8wfAOgCms2PIFmSxfRB5alLvUCxJavghhqRfV1PLRBA8QxeShxbmBwAHsAlGMEIjixvJk2S3vGcs72vJFkM2Lor0Y2otrYvkScGdJmFKKLV+CyfKl5aFluEu9BKHlSxOWehlNLR9d8ABRVh5ajhsIHMAuEGUJgShnLE+W3fKesbyjLV8a2bwM2suivZwmli8Pd1aAqajY8uWZLF9JHlqZu9TLE1q+EmGpV9bU8jEEDxBV5KFVuYHAAewCUYUQiKrG8mTZLe8Zyzva8pWQzSujvQraq2pi+WpwZ3WYGootX43J8jXlobW4S70aoeVrEpZ6LU0tH1PwAFFbHlqHGwgcwC4QtQmBqGMsT5bd8p6xvKMtXxPZvBbaa6O9jiaWrwt31oOpr9jydZks30Ae2pC71OsSWr4BYak31NTysQQPEI3koYHcQOAAdoFoRAhEoLE8WXbLe8byjrZ8A2TzhmhvhPZATSwfBHcGw4QotnwQk+VD5aFh3KUeRGj5UMJSD9PU8rEFDxCN5aFNuIHAAewC0ZgQiCbG8mTZLe8Zyzva8qHI5mFob4z2JppYvinc2QymuWLLN2WyfAt5aEvuUm9KaPkWhKXeUlPLxxE8QLSSh7bmBgIHsAtEK0IgWhvLk2W3vGcs72jLt0A2b4n2VmhvrYnl28CdbWHaKbZ8GybLt5eHduAu9TaElm9PWOodNLV8XMEDREd5aCduIHAAu0B0JASik7E8WXbLe8byjrZ8e2TzDmjviPZOmli+M9zZBaarYst3ZrJ8N3lod+5S70xo+W6Epd5dU8vHEzxA9JCH9uQGAgewC0QPQiB6GsuTZbe8ZyzvaMt3QzbvjvYeaO+pieV7wZ29YfootnwvJsv3lYf24y71XoSW70tY6v00tXx8wQNEf3noAG4gcAC7QPQnBGKAsTxZdst7xvKOtnxfZPN+aO+P9gGaWH4g3DkIZrBiyw9ksvwQeehQ7lIfSGj5IYSlPlRTyycQPEAMk4cO5wYCB7ALxDBCIIYby5Nlt7xnLO9oyw9BNh+K9mFoH66J5UfAnSNhRim2/Agmy4+Wh47hLvURhJYfTVjqYzS1fELBA8RYeeg4biBwALtAjCUEYpyxPFl2y3vG8o62/Ghk8zFoH4v2cZpYfjzcOQFmomLLj2ey/CR56GTuUh9PaPlJhKU+WVPLJxI8QEyRh07lBgIHsAvEFEIgphrLk2W3vGcs72jLT0I2n4z2KWifqonlp8Gd02FmKLb8NCbLz5SHzuIu9WmElp9JWOqzNLV8YsEDxGx56BxuIHAAu0DMJgRijrE8WXbLe8byjrb8TGTzWWifjfY5mlh+Ltw5D2a+YsvPZbL8AnnoQu5Sn0to+QWEpb5QU8snETxALJKHLuYGAgewC8QiQiAWG8uTZbe8ZyzvaMsvQDZfiPZFaF+sieWXwJ1LYZYptvwSJssvl4eu4C71JYSWX05Y6is0tXxSwQPESnnoKm4gcAC7QKwkBGKVsTxZdst7xvKOtvxyZPMVaF+J9lWaWH413LkGZq1iy69msvw6eeh67lJfTWj5dYSlvl5TyycTPEBskIdu5AYCB7ALxAZCIDYay5Nlt7xnLO9oy69DNl+P9g1o36iJ5TfBnZthtii2/CYmy2+Vh27jLvVNhJbfSljq2zS1fHLBA8R2eegObiBwALtAbCcEYoexPFl2y3vG8o62/FZk821o3472HZpYfifcuQtmt2LL72Sy/B556F7uUt9JaPk9hKW+V1PLpxA8QOyTh+7nBgIHsAvEPkIg9hvLk2W3vGcs72jL70E234v2fWjfr4nlD8CdB2EOKbb8ASbLH5aHHuEu9QOElj9MWOpHNLV8SsEDxFF56DFuIHAAu0AcJQTimLE8WXbLe8byjrb8YWTzI2g/ivZjmlj+ONx5AuakYssfZ7L8KXnoae5SP05o+VOEpX5aU8unEjxAnJGHnuUGAgewC8QZQiDOGsuTZbe8ZyzvaMufQjY/jfYzaD+rieXPwZ3nYS4otvw5JstflIde4i71c4SWv0hY6pc0tXxqwQPEZXnoFW4gcAC7QFwmBOKKsTxZdst7xvKOtvxFZPNLaL+M9iuaWP4q3HkN5rpiy19lsvwNeehN7lK/Smj5G4SlflNTy6cRPEDckofe5gYijaAD4hYhELeN5cmyW94zlne05W8gm99E+y2039bE8nfgzrsw9xRb/g6T5e/LQx9wl/odQsvfJyz1B5paPq3gAeKhPPQRNxA4gF0gHhIC8chYniy75T1jeUdb/j6y+QO0P0T7I00s/xjufALzVLHlHzNZ/pk89Dl3qT8mtPwzwlJ/rqnl0wkeIF7IQ19yA4ED2AXiBSEQL43lybJb3jOWd7TlnyGbP0f7C7S/1MTyr+DO1zBvFFv+FZPl38pD33GX+itCy78lLPV3mlo+veAB4r089AM3EDiAXSDeEwLxwVieLLvlPWN5R1v+LbL5O7S/R/sHTSz/Ee78BPNZseU/Mln+izz0K3epfyS0/BfCUv+qqeUzCB4gvslDv3MDgQPYBeIbIRDfjeXJslveM5Z3tOW/IJt/Rfs3tH/XxPJ/wZ0/wm9VbPm/mCz/6/ehEf4IQF3qfxFa/hdhqYcHJ8qo1PIZBQ8QLvJDBG4gcAC7QLhEoAMiQgRjearslveM5R1t+V/I5uGl+nt3QXuECHpY3hXudIOJGEGt5V0j8JR6JPkhMnepu0agK/VIhKUeWVPLZxI8QESRH6JyA4ED2AUiCiEQUY3lybJb3jOWd7TlIyGbR0Z7FLRH1cTy0eDO6DAxFFs+GpPlY8oPsbhLPRqh5WMSlnosTS2fWfAAEVt+iMMNBA5gF4jYhEDEMZYny255z1je0ZaPiWweC+2x0R5HE8vHhTvjwcRXbPm4TJZPID8k5C71uISWT0BY6gk1tXwWwQNEIvkhMTcQOIBdIBIRApHYWJ4su+U9Y3lHWz4BsnlCtCdCe2JNLJ8E7kwKk0yx5ZMwWT65/JCCu9STEFo+OWGpp9DU8lkFDxAp5YdU3EDgAHaBSEkIRCpjebLslveM5R1t+eTI5inQnhLtqTSxfGq4Mw1MWsWWT81k+XTyQ3ruUk9NaPl0hKWeXlPLZxM8QGSQHzJyA4ED2AUiAyEQGY3lybJb3jOWd7Tl0yGbp0d7BrRn1MTymeDOzDBZFFs+E5Pls8oP2bhLPROh5bMSlno2TS2fXfAAkV1+yMENBA5gF4jshEDkMJYny255z1je0ZbPimyeDe3Z0Z5DE8vnhDtzweRWbPmcTJb//cGDu9RzElrenbDUPTS1fA7BA4Sn/ODFDQQOYBcIT0IgvIzlybJb3jOWd7Tl3ZHNPdDuiXYvTSzvDXf6wPgqtrw3k+X95Ad/7lL3JrS8H2Gp+2tq+ZyCB4gA+SEP+1/2CTogAgiByGMsT5bd8p6xvKMt74ds7o/2ALTn0cTyeeHOfDD5FVs+L5PlC8gPBblLPS+h5QsQlnpBTS2fS/AAUUh+KMwNBA5gF4hChEAUNpYny255z1je0ZYvgGxeEO2F0F5YE8sXgTuLwhRTbPkiTJYvLj+U4C71IoSWL05Y6iU0tXxuwQNESfmhFDcQOIBdIEoSAlHKWJ4su+U9Y3lHW744snkJtJdEeylNLF8a7iwDU1ax5UszWb6c/FCeu9RLE1q+HGGpl9fU8u6CB4gK8kNFbiBwALtAVCAEoqKxPFl2y3vG8o62fDlk8/Jor4D2ippYvhLcWRmmimLLV2KyfFX5oRp3qVcitHxVwlKvpqnlPQQPENXlhxrcQOAAdoGoTghEDWN5suyW94zlHW35qsjm1dBeHe01NLF8TbizFkxtxZavyWT5OvJDXe5Sr0lo+TqEpV5XU8t7Ch4g6skP9bmBwAHsAlGPEIj6xvJk2S3vGcs72vJ1kM3ror0e2utrYvkGcGdDmEaKLd+AyfKB8kMQd6k3ILR8IGGpB2lqeS/BA0Sw/BDCDQQOYBeIYEIgQozlybJb3jOWd7TlA5HNg9AejPYQTSwfCneGwTRWbPlQJss3kR+acpd6KKHlmxCWelNNLe8teIBoJj805wYCB7ALRDNCIJoby5Nlt7xnLO9oyzdBNm+K9mZob66J5VvAnS1hWim2fAsmy7eWH9pwl3oLQsu3Jiz1Nppa3kfwANFWfmjHDQQOYBeItoRAtDOWJ8tuec9Y3tGWb41s3gbtbdHeThPLt4c7O8B0VGz59kyW7yQ/dOYu9faElu9EWOqdNbW8r+ABoov80JUbCBzALhBdCIHoaixPlt3ynrG8oy3fCdm8M9q7oL2rJpbvBnd2h+mh2PLdmCzfU37oxV3q3Qgt35Ow1Htpank/wQNEb/mhDzcQOIBdIHoTAtHHWJ4su+U9Y3lHW74nsnkvtPdGex9NLN8X7uwH01+x5fsyWX6A/DCQu9T7Elp+AGGpD9TU8v6CB4hB8sNgbiBwALtADCIEYrCxPFl2y3vG8o62/ABk84FoH4T2wZpYfgjcORRmmGLLD2Gy/HD5YQR3qQ8htPxwwlIfoanlAwQPECPlh1HcQOAAdoEYSQjEKGN5suyW94zlHW354cjmI9A+Eu2jNLH8aLhzDMxYxZYfzWT5cfLDeO5SH01o+XGEpT5eU8vnETxATJAfJnIDgQPYBWICIRATjeXJslveM5Z3tOXHIZuPR/sEtE/UxPKT4M7JMFMUW34Sk+Wnyg/TuEt9EqHlpxKW+jRNLZ9X8AAxXX6YwQ0EDmAXiOmEQMwwlifLbnnPWN7Rlp+KbD4N7dPRPkMTy8+EO2fBzFZs+ZlMlp8jP8zlLvWZhJafQ1jqczW1fD7BA8Q8+WE+NxA4gF0g5hECMd9Yniy75T1jeUdbfg6y+Vy0z0P7fE0svwDuXAizSLHlFzBZfrH8sIS71BcQWn4xYakv0dTy+QUPEEvlh2XcQOAAdoFYSgjEMmN5suyW94zlHW35xcjmS9C+FO3LNLH8crhzBcxKxZZfzmT5VfLDau5SX05o+VWEpb5aU8sXEDxArJEf1nIDgQPYBWINIRBrjeXJslveM5Z3tOVXIZuvRvsatK/VxPLr4M71MBsUW34dk+U3yg+buEt9HaHlNxKW+iZNLV9Q8ACxWX7Ywg0EDmAXiM2EQGwxlifLbnnPWN7Rlt+IbL4J7ZvRvkUTy2+FO7fBbFds+a1Mlt8hP+zkLvWthJbfQVjqOzW1fCHBA8Qu+WE3NxA4gF0gdhECsdtYniy75T1jeUdbfgey+U6070L7bk0svwfu3AuzT7Hl9zBZfr/8cIC71PcQWn4/Yakf0NTyhQUPEAflh0PcQOAAdoE4SAjEIWN5suyW94zlHW35/cjmB9B+EO2HNLH8YbjzCMxRxZY/zGT5Y/LDce5SP0xo+WOEpX5cU8sXETxAnJAfTnIDgQPYBeIEIRAnjeXJslveM5Z3tOWPIZsfR/sJtJ/UxPKn4M7TMGcUW/4Uk+XPyg/nuEv9FKHlzxKW+jlNLV9U8ABxXn64wA0EDmAXiPOEQFwwlifLbnnPWN7Rlj+LbH4O7efRfkETy1+EOy/BXFZs+YtMlr8iP1zlLvWLhJa/QljqVzW1fDHBA8Q1+eE6NxA4gF0grhECcd1Yniy75T1jeUdb/gqy+VW0X0P7dU0sfwPuvAlzS7HlbzBZ/rb8cIe71G8QWv42Yanf0dTyxQUPEHflh3vcQOAAdoG4SwjEPWN5suyW94zlHW3528jmd9B+F+33NLH8fbjzAcxDxZa/z2T5R/LDY+5Sv09o+UeEpf5YU8uXEDxAPJEfnnIDgQPYBeIJIRBPjeXJslveM5Z3tOUfIZs/RvsTtD/VxPLP4M7nMC8UW/4Zk+Vfyg+vuEv9GaHlXxKW+itNLV9S8ADxWn54ww0EDmAXiNeEQLwxlifLbnnPWN7Rln+JbP4K7a/R/kYTy7+FO9/BvFds+bdMlv8gP3zkLvW3hJb/QFjqHzW1fCnBA8Qn+eEzNxA4gF0gPhEC8dlYniy75T1jeUdb/gOy+Ue0f0L7Z00s/wXu/ArzTbHlvzBZ/rv88Bd3qX8htPx3wlL/S1PLlxY8QPyQH35yA4ED2AXiByEQP43lybJb3jOWd7TlvyOb/4X2H2j/qYnlf4WXHxSei6tay/9isnwEWd6urn8EoC71X4SWDz/6v3zrP5a6q6ueli8jeIBwk198RG4gcAC7QLgRAhHR1VieKrvlPWN5R1s+vJR/29wV7W5oj+iqh+UjwZ2RYaIotnwkV55SjyrLOxp3qUdypSv1qISlHk1Ty5cVPEBEl198DG4gcAC7QEQnBCKGsTxZdst7xvKOtnxUZPNoaI+O9hiaWD4m3BkLJrZiy8dksnwcWd5xuUs9JqHl4xCWelxNLV9O8AART37x8bmBwAHsAhGPEIj4xvJk2S3vGcs72vJxkM3joj0e2uNrYvkEcGdCmESKLZ+AyfKJZXkn4S71BISWT0xY6kk0tXx5wQNEUvnFJ+MGAgewC0RSQiCSGcuTZbe8ZyzvaMsnRjZPgvakaE+mieWTw50pYFIqtnxyJsunkuWdmrvUkxNaPhVhqafW1PIVBA8QaeQXn5YbCBzALhBpCIFIayxPlt3ynrG8oy2fCtk8NdrToD2tJpZPB3emh8mg2PLpmCyfUZZ3Ju5ST0do+YyEpZ5JU8tXFDxAZJZffBZuIHAAu0BkJgQii7E8WXbLe8byjrZ8RmTzTGjPjPYsmlg+K9yZDSa7YstnZbJ8DlneOblLPSuh5XMQlnpOTS1fSfAAkUt+8bm5gcAB7AKRixCI3MbyZNkt7xnLO9ryOZDNc6I9F9pza2J5d7jTA8ZTseXdmSzvJcvbm7vU3Qkt70VY6t6aWr6y4AHCR37xvtxA4AB2gfAhBMLXWJ4su+U9Y3lHW94L2dwb7T5o99XE8n5wpz9MgGLL+zFZPo8s77zcpe5HaPk8hKWeV1PLVxE8QOSTX3x+biBwALtA5CMEIr+xPFl2y3vG8o62fB5k87xoz4f2/JpYvgDcWTC8BxRbvgCT5QvL8i7CXeoFCC1fmLDUi2hq+aqCB4ii8osvxg0EDmAXiKKEQBQzlifLbnnPWN7Rli+MbF4E7UXRXkwTyxeHO0vAlFRs+eJMli8ly7s0d6kXJ7R8KcJSL62p5asJHiDKyC++LDcQOIBdIMoQAlHWWJ4su+U9Y3lHW74UsnlptJdBe1lNLF8O7iwPU0Gx5csxWb6iLO9K3KVejtDyFQlLvZKmlq8ueICoLL/4KtxA4AB2gahMCEQVY3my7Jb3jOUdbfmKyOaV0F4Z7VU0sXxVuLMaTHXFlq/KZPkasrxrsv8TtISWr0FY6jU1tXwNwQNELfnF1+YGAgewC0QtQiBqG8uTZbe8ZyzvaMvXQDavifZaaK+tieXrwJ11YeoptnwdJsvXl+XdgLvU6xBavj5hqTfQ1PI1BQ8QDeUX34gbCBzALhANCYFoZCxPlt3ynrG8oy1fH9m8Adobor2RJpYPhDuDYIIVWz6QyfIhsrxDuUs9kNDyIYSlHqqp5WsJHiDC5BffmBsIHMAuEGGEQDQ2lifLbnnPWN7Rlg9BNg9FexjaG2ti+SZwZ1OYZoot34TJ8s1lebfgLvUmhJZvTljqLTS1fG3BA0RL+cW34gYCB7ALREtCIFoZy5Nlt7xnLO9oyzdHNm+B9pZob6WJ5VvDnW1g2iq2fGsmy7eT5d2eu9RbE1q+HWGpt9fU8nUEDxAd5Bffkf1fwhF0QHQgBKKjsTxZdst7xvKOtnw7ZPP2aO+A9o6aWL4T3NkZpotiy3disnxXWd7duEu9E6HluxKWejdNLV9X8ADRXX7xPbiBwAHsAtGdEIgexvJk2S3vGcs72vJdkc27ob072ntoYvmecGcvmN6KLd+TyfJ9ZHn35S71noSW70NY6n01tXw9wQNEP/nF9+cGAgewC0Q/QiD6G8uTZbe8ZyzvaMv3QTbvi/Z+aO+vieUHwJ0DYQYptvwAJssPluU9hLvUBxBafjBhqQ/R1PL1BQ8QQ+UXP4wbCBzALhBDCYEYZixPlt3ynrG8oy0/GNl8CNqHon2YJpYfDneOgBmp2PLDmSw/Spb3aO5SH05o+VGEpT5aU8s3EDxAjJFf/FhuIHAAu0CMIQRirLE8WXbLe8byjrb8KGTz0Wgfg/axmlh+HNw5HmaCYsuPY7L8RFnek7hLfRyh5ScSlvokTS3fUPAAMVl+8VO4gcAB7AIxmRCIKcbyZNkt7xnLO9ryE5HNJ6F9MtqnaGL5qXDnNJjpii0/lcnyM2R5z+Qu9amElp9BWOozNbV8I8EDxCz5xc/mBqKRoANiFiEQs43lybJb3jOWd7TlZyCbz0T7LLTP1sTyc+DOuTDzFFt+DpPl58vyXsBd6nMILT+fsNQXaGr5QMEDxEL5xS/iBgIHsAvEQkIgFhnLk2W3vGcs72jLz0c2X4D2hWhfpInlF8OdS2CWKrb8YibLL5PlvZy71BcTWn4ZYakv19TyQYIHiBWu//Pbla6CFwgcwC4Q4UdTAbHS1VieKrvlPWN5R1s+vJR/23w52legfaWrHpZfBXeuhlnjqtbyq1x5Sn2tLO913KW+ypWu1NcSlvo6Vz0tHyx4gFgvv/gN3EDgAHaBWE8IxAZjebLslveM5R1t+bXI5uvQvh7tGzSx/Ea4cxPMZsWW38hk+S2yvLdyl/pGQstvISz1rZpaPkTwALFNfvHbuYHAAewCsY0QiO3G8mTZLe8Zyzva8luQzbeifRvat2ti+R1w506YXYotv4PJ8rtlee/hLvUdhJbfTVjqezS1fKjgAWKv/OL3cQOBA9gFYi8hEPuM5cmyW94zlne05Xcjm+9B+16079PE8vvhzgMwBxVbfj+T5Q/J8j7MXer7CS1/iLDUD2tq+TDBA8QR+cUf5QYCB7ALxBFCII4ay5Nlt7xnLO9oyx9CNj+M9iNoP6qJ5Y/BncdhTii2/DEmy5+U5X2Ku9SPEVr+JGGpn9LU8o0FDxCn5Rd/hhsIHMAuEKcJgThjLE+W3fKesbyjLX8S2fwU2k+j/Ywmlj8Ld56DOa/Y8meZLH9BlvdF7lI/S2j5C4SlflFTyzcRPEBckl/8ZW4gcAC7QFwiBOKysTxZdst7xvKOtvwFZPOLaL+E9suaWP4K3HkV5ppiy19hsvx1Wd43uEv9CqHlrxOW+g1NLd9U8ABxU37xt7iBwAHsAnGTEIhbxvJk2S3vGcs72vLXkc1voP0m2m9pYvnbcOcdmLuKLX+byfL3ZHnf5y7124SWv0dY6vc1tXwzwQPEA/nFP+QGAgewC8QDQiAeGsuTZbe8ZyzvaMvfQza/j/YHaH+oieUfwZ2PYZ4otvwjJss/leX9jLvUHxFa/ilhqT/T1PLNBQ8Qz+UX/4IbCBzALhDPCYF4YSxPlt3ynrG8oy3/FNn8Gdqfo/2FJpZ/CXe+gnmt2PIvmSz/Rpb3W+5Sf0lo+TeEpf5WU8u3EDxAvJNf/HtuIHAAu0C8IwTivbE8WXbLe8byjrb8G2Tzt2h/h/b3mlj+A9z5EeaTYst/YLL8Z1neX7hL/QOh5T8TlvoXTS3fUvAA8VV+8d+4gcAB7ALxlRCIb8byZNkt7xnLO9ryn5HNv6D9K9q/aWL573DnXzA/FFv+O5Plf8ry/sVd6t8JLf+TsNR/aWr5VoIHiN9Uu7gJXiBwALtAhB9NBYSLm7E8VXbLe8byjrb8T2TzX2gP//vm793FTQ/LR4A7XWHc3NRaPoIbT6lHlCEicZd6BDe6Uo9IWOqR3PS0fGvBA0RkGSIKNxA4gF0gIhMCEcVYniy75T1jeUdbPiKyeSS0R0Z7FE0sHxXujAYTXbHlozJZPoYMEZO71KMSWj4GYanH1NTybQQPELFkiNjcQOAAdoGIRQhEbGN5suyW94zlHW35GMjmMdEeC+2xNbF8HLgzLkw8xZaPw2T5+DJEAu5Sj0No+fiEpZ5AU8u3FTxAJJQhEnEDgQPYBSIhIRCJjOXJslveM5Z3tOXjI5snQHtCtCfSxPKJ4c4kMEkVWz4xk+WTyRDJuUs9MaHlkxGWenJNLd9O8ACRQoZIyQ0EDmAXiBSEQKQ0lifLbnnPWN7Rlk+GbJ4c7SnQnlITy6eCO1PDpFFs+VRMlk8rQ6TjLvVUhJZPS1jq6TS1fHvBA0R6GSIDNxA4gF0g0hMCkcFYniy75T1jeUdbPi2yeTq0p0d7Bk0snxHuzASTWbHlMzJZPosMkZW71DMSWj4LYaln1dTyHQQPENlkiOzcQOAAdoHIRghEdmN5suyW94zlHW35LMjmWdGeDe3ZNbF8DrgzJ0wuxZbPwWT53DKEO3ep5yC0fG7CUnfX1PIdBQ8QHjKEJzcQOIBdIDwIgfA0lifLbnnPWN7Rls+NbO6Odg+0e2pieS+40xvGR7HlvZgs7ytD+HGXuheh5X0JS91PU8t3EjxA+MsQAdxA4AB2gfAnBCLAWJ4su+U9Y3lHW94X2dwP7f5oD9DE8nngzrww+RRbPg+T5fPLEAW4Sz0PoeXzE5Z6AU0t31nwAFFQhijEDQQOYBeIgoRAFDKWJ8tuec9Y3tGWz49sXgDtBdFeSBPLF4Y7i8AUVWz5wkyWLyZDFOcu9cKEli9GWOrFNbV8F8EDRAkZoiQ3EDiAXSBKEAJR0lieLLvlPWN5R1u+GLJ5cbSXQHtJTSxfCu4sDVNGseVLMVm+rAxRjrvUSxFavixhqZfT1PJdBQ8Q5WWICtxA4AB2gShPCEQFY3my7Jb3jOUdbfmyyObl0F4e7RU0sXxFuLMSTGXFlq/IZPkqMkRV7lKvSGj5KoSlXlVTy3cTPEBUkyGqcwOBA9gFohohENWN5cmyW94zlne05asgm1dFezW0V9fE8jXgzpowtRRbvgaT5WvLEHW4S70GoeVrE5Z6HU0t313wAFFXhqjHDQQOYBeIuoRA1DOWJ8tuec9Y3tGWr41sXgftddFeTxPL14c7G8A0VGz5+kyWbyRDBHKXen1CyzciLPVATS3fQ/AAESRDBHMDgQPYBSKIEIhgY3my7Jb3jOUdbflGyOaBaA9Ce7Amlg+BO0NhwhRbPoTJ8o1liCbcpR5CaPnGhKXeRFPL9xQ8QDSVIZpxA4ED2AWiKSEQzYzlybJb3jOWd7TlGyObN0F7U7Q308TyzeHOFjAtFVu+OZPlW8kQrblLvTmh5VsRlnprTS3fS/AA0UaGaMsNBA5gF4g2hEC0NZYny255z1je0ZZvhWzeGu1t0N5WE8u3gzvbw3RQbPl2TJbvKEN04i71doSW70hY6p00tXxvwQNEZxmiCzcQOIBdIDoTAtHFWJ4su+U9Y3lHW74jsnkntHdGexdNLN8V7uwG012x5bsyWb6HDNGTu9S7Elq+B2Gp99TU8n0EDxC9ZIje3ED0EXRA9CIEorexPFl2y3vG8o62fA9k855o74X23ppYvg/c2Remn2LL92GyfH8ZYgB7qRNavj9hqQ/Q1PJ9BQ8QA2WIQdxA4AB2gRhICMQgY3my7Jb3jOUdbfn+yOYD0D4Q7YM0sfxguHMIzFDFlh/MZPlhMsRw7lIfTGj5YYSlPlxTy/cTPECMkCFGcgOBA9gFYgQhECON5cmyW94zlne05Ychmw9H+wi0j9TE8qPgztEwYxRbfhST5cfKEOO4S30UoeXHEpb6OE0t31/wADFehpjADQQOYBeI8YRATDCWJ8tuec9Y3tGWH4tsPg7t49E+QRPLT4Q7J8FMVmz5iUyWnyJDTOUu9YmElp9CWOpTNbX8AMEDxDQZYjo3EDiAXSCmEQIx3VieLLvlPWN5R1t+CrL5VLRPQ/t0TSw/A+6cCTNLseVnMFl+tgwxh7vUZxBafjZhqc/R1PIDBQ8Qc2WIedxA4AB2gZhLCMQ8Y3my7Jb3jOUdbfnZyOZz0D4X7fM0sfx8uHMBzELFlp/PZPlFMsRi7lKfT2j5RYSlvlhTyw8SPEAskSGWcgOBA9gFYgkhEEuN5cmyW94zlne05Rchmy9G+xK0L9XE8svgzuUwKxRbfhmT5VfKEKu4S30ZoeVXEpb6Kk0tP1jwALFahljD/m/HFHRArCYEYo2xPFl2y3vG8o62/Epk81VoX432NZpYfi3cuQ5mvWLLr2Wy/AYZYiN3qa8ltPwGwlLfqKnlhwgeIDbJEJu5gcAB7AKxiRCIzcbyZNkt7xnLO9ryG5DNN6J9E9o3a2L5LXDnVphtii2/hcny22WIHdylvoXQ8tsJS32HppYfKniA2ClD7OIGAgewC8ROQiB2GcuTZbe8ZyzvaMtvRzbfgfadaN+lieV3w517YPYqtvxuJsvvkyH2c5f6bkLL7yMs9f2aWn6Y4AHigAxxkBsIHMAuEAcIgThoLE+W3fKesbyjLb8P2Xw/2g+g/aAmlj8Edx6GOaLY8oeYLH9UhjjGXeqHCC1/lLDUj2lq+eGCB4jjMsQJbiBwALtAHCcE4oSxPFl2y3vG8o62/FFk82NoP472E5pY/iTceQrmtGLLn2Sy/BkZ4ix3qZ8ktPwZwlI/q6nlRwgeIM7JEOe5gcAB7AJxjhCI88byZNkt7xnLO9ryZ5DNz6L9HNrPa2L5C3DnRZhLii1/gcnyl2WIK9ylfoHQ8pcJS/2KppYfKXiAuCpDXOMGAgewC8RVQiCuGcuTZbe8ZyzvaMtfRja/gvaraL+mieWvw503YG4qtvx1JsvfkiFuc5f6dULL3yIs9duaWn6U4AHijgxxlxsIHMAuEHcIgbhrLE+W3fKesbyjLX8L2fw22u+g/a4mlr8Hd96HeaDY8veYLP9QhnjEXer3CC3/kLDUH2lq+dGCB4jHMsQTbiBwALtAPCYE4omxPFl2y3vG8o62/ENk80dof4z2J5pY/inc+QzmuWLLP2Wy/AsZ4iV3qT8ltPwLwlJ/qanlxwgeIF7JEK+5gcAB7ALxihCI18byZNkt7xnLO9ryL5DNX6L9Fdpfa2L5N3DnW5h3ii3/hsny72WID9yl/obQ8u8JS/2DppYfK3iA+ChDfOIGAgewC8RHQiA+GcuTZbe8ZyzvaMu/Rzb/gPaPaP+kieU/w51fYL4qtvxnJst/kyG+c5f6Z0LLfyMs9e+aWn6c4AHiLxniBzcQOIBdIP4iBOKHsTxZdst7xvKOtvw3ZPPvaP8L7T80sfxPuPNXeAFGVGv5n0yWd4n4P7+NEPGPANSl/pPQ8uFH/5dv/cdSjxBRT8uPFzxAuEoQ3LiBwAHsAuFKCIRbRGN5quyW94zlHW358FL+bfMIaHdFu1tEPSwfEe6MBBNZseUjRuQp9SiyzKNyl3rEiHSlHoWw1KNqavkJggeIaBKE6NxA4AB2gYhGCER0Y3my7Jb3jOUdbfkoyOZR0R4N7dE1sXwMuDMmTCzFlo/BZPnYsszjcJd6DELLxyYs9TiaWn6i4AEirgQhHjcQOIBdIOISAhHPWJ4su+U9Y3lHWz42snkctMdFezxNLB8f7kwAk1Cx5eMzWT6RLPPE3KUen9DyiQhLPbGmlp8keIBIIkFIyg0EDmAXiCSEQCQ1lifLbnnPWN7Rlk+EbJ4Y7UnQnlQTyyeDO5PDpFBs+WRMlk8pyzwVd6knI7R8SsJST6Wp5ScLHiBSSxDScAOBA9gFIjUhEGmM5cmyW94zlne05VMim6dCe2q0p9HE8mnhznQw6RVbPi2T5TPIMs/IXeppCS2fgbDUM2pq+SmCB4hMEoTM3EDgAHaByEQIRGZjebLslveM5R1t+QzI5hnRngntmTWxfBa4MytMNsWWz8Jk+eyyzHNwl3oWQstnJyz1HJpafqrgASKnBCEXNxA4gF0gchICkctYniy75T1jeUdbPjuyeQ6050R7Lk0snxvudIfxUGz53EyW95Rl7sVd6rkJLe9JWOpemlp+muABwluC4MMNBA5gFwhvQiB8jOXJslveM5Z3tOU9kc290O6Ndh9NLO8Ld/rB+Cu2vC+T5QNkmefhLnVfQssHEJZ6Hk0tP13wAJFXgpCPGwgcwC4QeQmByGcsT5bd8p6xvKMtH4BsngftedGeTxPL54c7C8AUVGz5/EyWLyTLvDB3qecntHwhwlIvrKnlZwgeIIpIEIpyA4ED2AWiCCEQRY3lybJb3jOWd7TlCyGbF0Z7EbQX1cTyxeDO4jAlFFu+GJPlS8oyL8Vd6sUILV+SsNRLaWr5mYIHiNIShDLcQOAAdoEoTQhEGWN5suyW94zlHW35ksjmpdBeGu1lNLF8WbizHEx5xZYvy2T5CrLMK3KXellCy1cgLPWKmlp+luABopIEoTI3EDiAXSAqEQJR2VieLLvlPWN5R1u+ArJ5RbRXQntlTSxfBe6sClNNseWrMFm+uizzGtylXoXQ8tUJS72GppafLXiAqClBqMUNBA5gF4iahEDUMpYny255z1je0ZavjmxeA+010V5LE8vXhjvrwNRVbPnaTJavJ8u8Pnep1ya0fD3CUq+vqeXnCB4gGkgQGnIDMUfQAdGAEIiGxvJk2S3vGcs72vL1kM3ro70B2htqYvlGcGcgTJBiyzdisnywLPMQ7lJvRGj5YMJSD9HU8nMFDxChEoQwbiBwALtAhBICEWYsT5bd8p6xvKMtH4xsHoL2ULSHaWL5xnBnE5imii3fmMnyzWSZN+cu9caElm9GWOrNNbX8PMEDRAsJQktuIHAAu0C0IASipbE8WXbLe8byjrZ8M2Tz5mhvgfaWmli+FdzZGqaNYsu3YrJ8W1nm7bhLvRWh5dsSlno7TS0/X/AA0V6C0IEbCBzALhDtCYHoYCxPlt3ynrG8oy3fFtm8Hdrbo72DJpbvCHd2gums2PIdmSzfRZZ5V+5S70ho+S6Epd5VU8svEDxAdJMgdOcGAgewC0Q3QiC6G8uTZbe8ZyzvaMt3QTbvivZuaO+uieV7wJ09YXoptnwPJsv3lmXeh7vUexBavjdhqffR1PILBQ8QfSUI/biBwAHsAtGXEIh+xvJk2S3vGcs72vK9kc37oL0v2vtpYvn+cOcAmIGKLd+fyfKDZJkP5i71/oSWH0RY6oM1tfwiwQPEEAnCUG4gcAC7QAwhBGKosTxZdst7xvKOtvwgZPPBaB+C9qGaWH4Y3DkcZoRiyw9jsvxIWeajuEt9GKHlRxKW+ihNLb9Y8AAxWoIwhhsIHMAuEKMJgRhjLE+W3fKesbyjLT8S2XwU2kejfYwmlh8Ld46DGa/Y8mOZLD9BlvlE7lIfS2j5CYSlPlFTyy8RPEBMkiBM5gYCB7ALxCRCICYby5Nlt7xnLO9oy09ANp+I9klon6yJ5afAnVNhpim2/BQmy0+XZT6Du9SnEFp+OmGpz9DU8ksFDxAzJQizuIHAAewCMZMQiFnG8mTZLe8Zyzva8tORzWegfSbaZ2li+dlw5xyYuYotP5vJ8vNkmc/nLvXZhJafR1jq8zW1/DLBA8QCCcJCbiBwALtALCAEYqGxPFl2y3vG8o62/Dxk8/loX4D2hZpYfhHcuRhmiWLLL2Ky/FJZ5svY/81WhJZfSljqyzS1/HLBA8RyCcIKbiBwALtALCcEYoWxPFl2y3vG8o62/FJk82VoX472FZpYfiXcuQpmtWLLr2Sy/BpZ5mu5S30loeXXEJb6Wk0tv0LwALFOgrCeGwgcwC4Q6wiBWG8sT5bd8p6xvKMtvwbZfC3a16F9vSaW3wB3boTZpNjyG5gsv1mW+RbuUt9AaPnNhKW+RVPLrxQ8QGyVIGxj/8s+QQfEVkIgthnLk2W3vGcs72jLb0Y234L2rWjfponlt8OdO2B2Krb8dibL75Jlvpu71LcTWn4XYanv1tTyqwQPEHskCHu5gcAB7AKxhxCIvcbyZNkt7xnLO9ryu5DNd6N9D9r3amL5fXDnfpgDii2/j8nyB2WZH+Iu9X2Elj9IWOqHNLX8asEDxGEJwhFuIHAAu0AcJgTiiLE8WXbLe8byjrb8QWTzQ2g/jPYjmlj+KNx5DOa4YssfZbL8CVnmJ7lL/Sih5U8QlvpJTS2/RvAAcUqCcJobCBzALhCnCIE4bSxPlt3ynrG8oy1/Atn8JNpPof20JpY/A3eehTmn2PJnmCx/Xpb5Be5SP0No+fOEpX5BU8uvFTxAXJQgXOIGAgewC8RFQiAuGcuTZbe8ZyzvaMufRza/gPaLaL+kieUvw51XYK4qtvxlJstfk2V+nbvULxNa/hphqV/X1PLrBA8QNyQIN7mBwAHsAnGDEIibxvJk2S3vGcs72vLXkM2vo/0G2m9qYvlbcOdtmDuKLX+LyfJ3ZZnf4y71W4SWv0tY6vc0tfx6wQPEfQnCA24gcAC7QNwnBOKBsTxZdst7xvKOtvxdZPN7aL+P9geaWP4h3PkI5rFiyz9ksvwTWeZPuUv9IaHlnxCW+lNNLb9B8ADxTILwnBsIHMAuEM8IgXhuLE+W3fKesbyjLf8E2fwp2p+h/bkmln8Bd76EeaXY8i+YLP9alvkb7lJ/QWj514Sl/kZTy28UPEC8lSC84wYCB7ALxFtCIN4Zy5Nlt7xnLO9oy79GNn+D9rdof6eJ5d/DnR9gPiq2/Hsmy3+SZf6Zu9TfE1r+E2Gpf9bU8psEDxBfJAhfuYHAAewC8YUQiK/G8mTZLe8Zyzva8p+QzT+j/Qvav2pi+W9w53eYvxRb/huT5X/IMv/JXerfCC3/g7DUf2pq+c2CB4hfv0GIJHiBwAHsAvGLEIjw4EQZjeWFsfz/L5b/gWz+E+2/0B7+N9DB8i5wZwQY10hqLe8SiafU3eQXFZG71HEAu6XuFomu1CNG0tPyWwQPEJEkCJG5gcAB7AIRiRCIyMbyZNkt7xnLO9rybpH+afOIaI+E9siaWD4K3BkVJppiy0dhsnx0+UXF4C71KISWj05Y6jE0tfxWwQNETAlCLG4gcAC7QMQkBCKWsTxZdst7xvKOtnx0ZPMYaI+J9liaWD423BkHJq5iy8dmsnw8+UXF5y712ISWj0dY6vE1tfw2wQNEAglCQm4gcAC7QCQgBCKhsTxZdst7xvKOtnw8ZPP4aE+A9oSaWD4R3JkYJoliyydisnxS+UUl4y71RISWT0pY6sk0tfx2wQNEcglCCm4gcAC7QCQnBCKFsTxZdst7xvKOtnxSZPNkaE+O9hSaWD4l3JkKJrViy6dksnwa+UWl5S71lISWT0NY6mk1tfwOwQNEOglCem4gcAC7QKQjBCK9sTxZdst7xvKOtnwaZPO0aE+H9vSaWD4D3JkRJpNiy2dgsnxm+UVl4S71DISWz0xY6lk0tfxOwQNEVglCNm4gcAC7QGQlBCKbsTxZdst7xvKOtnxmZPMsaM+K9myaWD473JkDJqdiy2dnsnwu+UXl5i717ISWz0VY6rk1tfwuwQOEuwTBgxsIHMAuEO6EQHgYy5Nlt7xnLO9oy+dCNs+Ndne0e2hieU+40wvGW7HlPZks7yO/KF/uUvcktLwPYan7amr53YIHCD8Jgj83EDiAXSD8CIHwN5Yny255z1je0Zb3QTb3Rbsf2v01sXwA3JkHJq9iywcwWT6f/KLyc5d6AKHl8xGWen5NLb9H8ABRQIJQkBuIPYIOiAKEQBQ0lifLbnnPWN7Rls+HbJ4f7QXQXlATyxeCOwvDFFFs+UJMli8qv6hi3KVeiNDyRQlLvZimlt8reIAoLkEowQ0EDmAXiOKEQJQwlifLbnnPWN7Rli+KbF4M7cXRXkITy5eEO0vBlFZs+ZJMli8jv6iy3KVektDyZQhLvaymlt8neIAoJ0Eozw0EDmAXiHKEQJQ3lifLbnnPWN7Rli+DbF4W7eXQXl4Ty1eAOyvCVFJs+QpMlq8sv6gq3KVegdDylQlLvYqmlt8veICoKkGoxg0EDmAXiKqEQFQzlifLbnnPWN7Rlq+MbF4F7VXRXk0Ty1eHO2vA1FRs+epMlq8lv6ja3KVendDytQhLvbamlj8geICoI0Goyw0EDmAXiDqEQNQ1lifLbnnPWN7Rlq+FbF4b7XXQXlcTy9eDO+vDNFBs+XpMlm8ov6hG3KVej9DyDQlLvZGmlj8oeIAIlCAEcQOBA9gFIpAQiCBjebLslveM5R1t+YbI5o3QHoj2IE0sHwx3hsCEKrZ8MJPlw+QX1Zi71IMJLR9GWOqNNbX8IcEDRBMJQlNuIHAAu0A0IQSiqbE8WXbLe8byjrZ8GLJ5Y7Q3QXtTTSzfDO5sDtNCseWbMVm+pfyiWnGXejNCy7ckLPVWmlr+sOABorUEoQ03EDiAXSBaEwLRxlieLLvlPWN5R1u+JbJ5K7S3RnsbTSzfFu5sB9NeseXbMlm+g/yiOnKXeltCy3cgLPWOmlr+iOABopMEoTM3EDiAXSA6EQLR2VieLLvlPWN5R1u+A7J5R7R3QntnTSzfBe7sCtNNseW7MFm+u/yienCXehdCy3cnLPUemlr+qOABoqcEoRc3EDiAXSB6EgLRy1ieLLvlPWN5R1u+O7J5D7T3RHsvTSzfG+7sA9NXseV7M1m+n/yi+nOXem9Cy/cjLPX+mlr+mOABYoAEYSA3EDiAXSAGEAIx0FieLLvlPWN5R1u+H7J5f7QPQPtATSw/CO4cDDNEseUHMVl+qPyihnGX+iBCyw8lLPVhmlr+uOABYrgEYQQ3EDiAXSCGEwIxwlieLLvlPWN5R1t+KLL5MLQPR/sITSw/Eu4cBTNaseVHMll+jPyixnKX+khCy48hLPWxmlr+hOABYpwEYTw3EDiAXSDGEQIx3lieLLvlPWN5R1t+DLL5WLSPQ/t4TSw/Ae6cCDNJseUnMFl+svyipnCX+gRCy08mLPUpmlr+pOABYqoEYRo3EDiAXSCmEgIxzVieLLvlPWN5R1t+MrL5FLRPRfs0TSw/He6cATNTseWnM1l+lvyiZnOX+nRCy88iLPXZmlr+lOABYo4EYS43EDiAXSDmEAIx11ieLLvlPWN5R1t+FrL5bLTPQftcTSw/D+6cD7NAseXnMVl+ofyiFnGX+jxCyy8kLPVFmlr+tOABYrEEYQk3EDiAXSAWEwKxxFieLLvlPWN5R1t+IbL5IrQvRvsSTSy/FO5cBrNcseWXMll+hfyiVnKX+lJCy68gLPWVmlr+jOABYpUEYTU3EDiAXSBWEQKx2lieLLvlPWN5R1t+BbL5SrSvQvtqTSy/Bu5cC7NOseXXMFl+vfyiNnCX+hpCy68nLPUNmlr+rOABYqMEYRM3EDiAXSA2EgKxyVieLLvlPWN5R1t+PbL5BrRvRPsmTSy/Ge7cArNVseU3M1l+m/yitnOX+mZCy28jLPXtmlr+nOABYocEYSc3EDiAXSB2EAKx01ieLLvlPWN5R1t+G7L5drTvQPtOTSy/C+7cDbNHseV3MVl+r/yi9nGX+i5Cy+8lLPV9mlr+vOABYr8E4QA3EDiAXSD2EwJxwFieLLvlPWN5R1t+L7L5PrTvR/sBTSx/EO48BHNYseUPMln+iPyijnKX+kFCyx8hLPWjmlr+guAB4pgE4Tg3EDiAXSCOEQJx3FieLLvlPWN5R1v+CLL5UbQfQ/txTSx/Au48CXNKseVPMFn+tPyiznCX+glCy58mLPUzmlr+ouAB4qwE4Rw3EDiAXSDOEgJxzlieLLvlPWN5R1v+NLL5GbSfRfs5TSx/Hu68AHNRseXPM1n+kvyiLrP/E7SElr9EWOqXNbX8JcEDxBUJwlVuIHAAu0BcIQTiqrE8WXbLe8byjrb8JWTzy2i/gvarmlj+Gtx5HeaGYstfY7L8TflF3eIu9WuElr9JWOq3NLX8ZcEDxG0Jwh1uIHAAu0DcJgTijrE8WXbLe8byjrb8TWTzW2i/jfY7mlj+Ltx5D+a+YsvfZbL8A/lFPeQu9buEln9AWOoPNbX8FcEDxCMJwmNuIHAAu0A8IgTisbE8WXbLe8byjrb8A2Tzh2h/hPbHmlj+Cdz5FOaZYss/YbL8c/lFveAu9SeEln9OWOovNLX8VcEDxEsJwituIHAAu0C8JATilbE8WXbLe8byjrb8c2TzF2h/ifZXmlj+Ndz5BuatYsu/ZrL8O/lFvecu9deEln9HWOrvNbX8NcEDxAcJwkf2fwlH0AHxgRCIj8byZNkt7xnLO9ry75DN36P9A9o/amL5T3DnZ5gvii3/icnyX+UX9Y271D8RWv4rYal/09Ty1wUPEN8lCH9xA4ED2AXiOyEQfxnLk2W3vGcs72jLf0U2/4b272j/SxPL/wi/E+aXYsv/YLK8iCzvjfxHAOpS/0Fo+fCj/8u3/mOpu0TW0/I3BA8QESQIrtxA4AB2gYhACIRrZGN5quyW94zlHW358FL+bXMXtEdAu2tkPSzvBndGhIkUWa3l3SLzlHpkWeZRuEvdLTJdqUcmLPUomlr+puABIqoEIRo3EDiAXSCiEgIRzVieLLvlPWN5R1s+MrJ5FLRHRXs0TSwfHe6MARNTseWjM1k+lizz2NylHp3Q8rEISz22ppa/JXiAiCNBiMsNBA5gF4g4hEDENZYny255z1je0ZaPhWweG+1x0B5XE8vHgzvjwyRQbPl4TJZPKMs8EXepxyO0fELCUk+kqeVvCx4gEksQknADgQPYBSIxIRBJjOXJslveM5Z3tOUTIpsnQntitCfRxPJJ4c5kMMkVWz4pk+VTyDJPyV3qSQktn4Kw1FNqavk7ggeIVBKE1NxA3BF0QKQiBCK1sTxZdst7xvKOtnwKZPOUaE+F9tSaWD4N3JkWJp1iy6dhsnx6WeYZuEs9DaHl0xOWegZNLX9X8ACRUYKQiRsIHMAuEBkJgchkLE+W3fKesbyjLZ8e2TwD2jOiPZMmls8Md2aByarY8pmZLJ9Nlnl27lLPTGj5bISlnl1Ty98TPEDkkCDk5AYCB7ALRA5CIHIay5Nlt7xnLO9oy2dDNs+O9hxoz6mJ5XPBnblh3BVbPheT5T1kmXtyl3ouQst7EJa6p6aWvy94gPCSIHhzA4ED2AXCixAIb2N5suyW94zlHW15D2RzT7R7od1bE8v7wJ2+MH6KLe/DZHl/WeYB3KXuQ2h5f8JSD9DU8g8EDxB5JAh5uYHAAewCkYcQiLzG8mTZLe8Zyzva8v7I5gFoz4P2vJpYPh/cmR+mgGLL52OyfEFZ5oW4Sz0foeULEpZ6IU0t/1DwAFFYglCEGwgcwC4QhQmBKGIsT5bd8p6xvKMtXxDZvBDaC6O9iCaWLwp3FoMprtjyRZksX0KWeUnuUi9KaPkShKVeUlPLPxI8QJSSIJTmBgIHsAtEKUIgShvLk2W3vGcs72jLl0A2L4n2UmgvrYnly8CdZWHKKbZ8GSbLl5dlXoG71MsQWr48YalX0NTyjwUPEBUlCJW4gcAB7AJRkRCISsbyZNkt7xnLO9ry5ZHNK6C9ItoraWL5ynBnFZiqii1fmcny1WSZV+cu9cqElq9GWOrVNbX8E8EDRA0JQk1uIHAAu0DUIASiprE8WXbLe8byjrZ8NWTz6mivgfaamli+FtxZG6aOYsvXYrJ8XVnm9bhLvRah5esSlno9TS3/VPAAUV+C0IAbCBzALhD1CYFoYCxPlt3ynrG8oy1fF9m8Htrro72BJpZvCHc2gglUbPmGTJYPkmUezF3qDQktH0RY6sGaWv6Z4AEiRIIQyg0EDmAXiBBCIEKN5cmyW94zlne05YOQzYPRHoL2UE0sHwZ3NoZpotjyYUyWbyrLvBl3qYcRWr4pYak309TyzwUPEM0lCC24gcAB7ALRnBCIFsbyZNkt7xnLO9ryTZHNm6G9OdpbaGL5lnBnK5jWii3fksnybWSZt+Uu9ZaElm9DWOptNbX8C8EDRDsJQntuIHAAu0C0IwSivbE8WXbLe8byjrZ8G2Tztmhvh/b2mli+A9zZEaaTYst3YLJ8Z1nmXbhLvQOh5TsTlnoXTS3/UvAA0VWC0I0bCBzALhBdCYHoZixPlt3ynrG8oy3fGdm8C9q7or2bJpbvDnf2gOmp2PLdmSzfS5Z5b+5S705o+V6Epd5bU8u/EjxA9JEg9OUGAgewC0QfQiD6GsuTZbe8ZyzvaMv3QjbvjfY+aO+rieX7wZ39YQYotnw/JssPlGU+iLvU+xFafiBhqQ/S1PKvBQ8QgyUIQ7iBwAHsAjGYEIghxvJk2S3vGcs72vIDkc0HoX0w2odoYvmhcOcwmOGKLT+UyfIjZJmP5C71oYSWH0FY6iM1tfwbwQPEKAnCaG4gcAC7QIwiBGK0sTxZdst7xvKOtvwIZPORaB+F9tGaWH4M3DkWZpxiy49hsvx4WeYTuEt9DKHlxxOW+gRNLf9W8AAxUYIwiRsIHMAuEBMJgZhkLE+W3fKesbyjLT8e2XwC2ieifZImlp8Md06BmarY8pOZLD9Nlvl07lKfTGj5aYSlPl1Ty78TPEDMkCDM5AYCB7ALxAxCIGYay5Nlt7xnLO9oy09DNp+O9hlon6mJ5WfBnbNh5ii2/Cwmy8+VZT6Pu9RnEVp+LmGpz9PU8u8FDxDzJQgLuIHAAewCMZ8QiAXG8mTZLe8Zyzva8nORzeehfT7aF2hi+YVw5yKYxYotv5DJ8ktkmS/lLvWFhJZfQljqSzW1/AfBA8QyCcJybiBwALtALCMEYrmxPFl2y3vG8o62/BJk86VoX4b25ZpYfgXcuRJmlWLLr2Cy/GpZ5mu4S30FoeVXE5b6Gk0t/1HwALFWgrCOGwgcwC4QawmBWGcsT5bd8p6xvKMtvxrZfA3a16J9nSaWXw93boDZqNjy65ksv0mW+WbuUl9PaPlNhKW+WVPLfxI8QGyRIGzlBgIHsAvEFkIgthrLk2W3vGcs72jLb0I234z2LWjfqonlt8Gd22F2KLb8NibL75Rlvou71LcRWn4nYanv0tTynwUPELslCHu4gcAB7AKxmxCIPcbyZNkt7xnLO9ryO5HNd6F9N9r3aGL5vXDnPpj9ii2/l8nyB2SZH+Qu9b2Elj9AWOoHNbX8F8EDxCEJwmFuIHAAu0AcIgTisLE8WXbLe8byjrb8AWTzg2g/hPbDmlj+CNx5FOaYYssfYbL8cVnmJ7hL/Qih5Y8TlvoJTS3/VfAAcVKCcIobCBzALhAnCYE4ZSxPlt3ynrG8oy1/HNn8BNpPov2UJpY/DXeegTmr2PKnmSx/Tpb5ee5SP01o+XOEpX5eU8t/EzxAXJAgXOQGAgewC8QFQiAuGsuTZbe8ZyzvaMufQzY/j/YLaL+oieUvwZ2XYa4otvwlJstflWV+jbvULxFa/iphqV/T1PLfBQ8Q1yUIN7iBwAHsAnGdEIgbxvJk2S3vGcs72vJXkc2vof062m9oYvmbcOctmNuKLX+TyfJ3ZJnf5S71m4SWv0NY6nc1tfxfggeIexKE+9xA4AB2gbhHCMR9Y3my7Jb3jOUdbfk7yOZ30X4P7fc1sfwDuPMhzCPFln/AZPnHssyfcJf6A0LLPyYs9SeaWv6H4AHiqQThGTcQOIBdIJ4SAvHMWJ4su+U9Y3lHW/4xsvkTtD9F+zNNLP8c7nwB81Kx5Z8zWf6VLPPX3KX+nNDyrwhL/bWmlv8peIB4I0F4yw0EDmAXiDeEQLw1lifLbnnPWN7Rln+FbP4a7W/Q/lYTy7+DO9/DfFBs+XdMlv8oy/wTd6m/I7T8R8JS/6Sp5X8JHiA+SxC+cAOBA9gF4jMhEF+M5cmyW94zlne05T8im39C+2e0f9HE8l/hzm8w3/8owQh//Lns9paLC12ffiXsrf8ts7u9Xx7Che7nF8GFlud/CBwZ3EX+DFzlH48ouQ9H43e3R4OJDhMDJiZMLJjYMHFg4sLEg4kPkwAmIUwimMQwSWCSwiSDSQ6TAiYlTCqY1DBpYNLCpINJD5MBJiNMJpjMMFlgssJkg8kOkwMmJ0wumNzhPxMYDxjP8J81jDeMD4wvjB+MP0wATB6YvDD5YPLDFIApKL/zwjBFYIrCFIMpDlMCpiRMKZjSMGVgysKUgykPUwGmIkwlmMowVWCqwlSDqQ5TA6YmTC2Y2jB1YOrC1IOpD9MApiFMI5hAmCCYYJgQmFCYMJjGME1gmsI0g2kO0wKmJUwrmNYwbWDawrSDaQ/TAaYjTCeYzjBdYLrCdIPpDtMDpidML5jeMH1g+sL0g+kPMwBmIMwgmMEwQ2CGwgyDGQ4zAmYkzCiY0TBjYMbCjIMZDzMBZiLMJJjJMFNgpsJMg5kOMwNmJswsmNkwc2DmwsyDmQ+zAGYhzCKYxTBLYJbCLINZDrMCZiXMKpjVMGtg1sKsg1kPswFmI8wmmM0wW2C2wmyD2Q6zA2YnzC6Y3TB7YPbC7IPZD3MA5iDMIZjDMEdgjsIcgzkOcwLmJMwpmNMwZ2DOwpyDOQ9zAeYizCWYyzBXYK7CXIO5DnMD5ibMLZjbMHdg7sLcg7kP8wDmIcwjmMcwT2CewjyDeQ7zAuYlzCuY1zBvYML/t4/D/5cRw/93k8L/VxXC/zuXw/8bGcP/+5rC/9scwv+znuH/SZDwf59o+L+LJPxfYwp3QPhfn4b/nf93/4V3QoS/+Sv7378rg/zt77/Wi4D+eHh3FJKf3e398oj6x5+X8n1/d2+/qH+Tj/B+r6jin53K9fP5/SbD++6//5KgWJ9/vv9nlvBfMeVnjMzvv024N2KJf+5x0N8m/Fdx9LbLH3+sxN/8eTkzAxM+v993Y3gffnnG/5v73VC28F9F+4h//Po//nk9/vwd0eXPP5V8z/Vv7nD54yZX8e+/c/E3v8/lb96J8Mf/r8u/+fPj3K7iX7+Df3fb3/0cxd/8vr+7zfU/3Ob2N7f9+W6E/yXHv/vz4Jt+/3xiin/9Wbv88cf+7vbw7/U3N259rH+8kPz97jZ+wT9c+8c/3nOV70cU/8oB/vNH/OP/P738HA3dj38Whf6Pd4b5BXqEeQWGwT9FEBLiHRwY74/3Bfp5hv+c/h9bH9tfDusHAA==","debug_symbols":"5dzfilRXFsDhd+lrL2qt/T+vMgzBGBME0aBmYAh59zk9k3acjgkEJ5DV341Qemq7l+fU9gda309337785sfvv3715ru37++++ttPd6/fvnj+4dXbN9ern+5u//6p9z88f3P/6v2H5+8+3H0Vez+7e/nm27uvMufPz+6+e/X65d1XM35+9utLo/1yaYxPLs3PXdrX+HhttI8X5+0zF+ct4mEPt7Z//+KWp/9ycWttfXrx35/dxZMYsd/yYcQ++qMR8+nfxfb072L/q47Y8uMe2tqPdj2+dNdnfFz89td89uaTGPF3n7319O/ifvp38fxVR/zdEyRuT//hi3j6T18kcB8bcB97zWMEKJEAUiSAFgkgRqJmjSRQIwnUSAI1kkCNZK95jAA1kkCNJFAjCdRI1qyRBtRIA2qkATXSgBppveYxAtRIA2qkATXSgBppNWukAzXSgRrpQI10oEZ6r3mMADXSgRrpQI10oEZ6zRoZQI0MoEYGUCMDqJHRax4jQI0MoEYGUCMDqJFRs0YmUCMTqJEJ1MgEamT2mseI8H0aoEYmUCMTqJFZs0YWUCMLqJEF1MgCamT1mscIUCNL+HovUCMLqJFVs0Y2UCMbqJEN1MgGamT3mscIUCMbqJEtaCNAjeyaNXKAGjlAjRygRg5QI6fXPEaAGjlAjRygRo6An1XVzwT+7Cb4ZzcBQLsJAtqtFz1LBAPtJiBoN0FBuwkM2q1olxgsq9AlBMxKyKxVaVbCZiVwVkJnJXjWoj5rCEBrCEJrCERrCEZrFEVaQ1BaQ2BaQ3BaQ4Bao6jUGgLVGoLVGgLWGoLWGkW51hC81hDA1hDE1hDI1ihqtoaAtoagtobAtobgtkZRuDUEuTUEujUEuzUEvDWK6q0h8K0h+K0hAK4hCK5RlHANwXANAXENQXENgXGNoo5rCJBrCJJrCJRrCJZrFMVcQ9BcQ+BcQ/BcQwBdo6joGgLpGoLpGgLqGoLqGkVZ1xBc1xBg1xBk1xBo1yhqu4aAu4agu4bAu4bgu0ZR4DUE4TUE4jUE4zUE5DWKKq8hMK8hOK8hQK8hSK9RlHoNwXoNAXsNQXsNgXuNot5rCt5rCt5rCt5rCt5r3nrRswTokhS81xS81xS81yzqvabgvabgvabgvabgvWZR7zUF7zUF7zUF7zUF7zWLeq8peK8peK8peK8peK9Z1HtNwXtNwXtNwXtNwXvNot5rCt5rCt5rCt5rCt5rFvVeU/BeU/BeU/BeU/Bes6j3moL3moL3moL3moL3mkW91xS81xS81xS81xS81yzqvabgvabgvabgvabgvWZR7zUF7zUF7zUF7zUF7zWLeq8peK8peK8peK8peK9Z1HtNwXtNwXtNwXtNwXvNot5rCt5rCt5rCt5rCt5rFvVeU/BeU/BeU/BeU/Bes6j3moL3moL3moL3moL3mkW91xS81xS81xS81xS81yzqvabgvabgvabgvabgvWZR7zUF7zUF7zUF7zUF7zWLeq9N8F6b4L02wXttgvfabr3oWQJ0SRO81yZ4r03wXltR77UJ3msTvNcmeK9N8F5bUe+1Cd5rE7zXJnivTfBeW1HvtQneaxO81yZ4r03wXltR77UJ3msTvNcmeK9N8F5bUe+1Cd5rE7zXJnivTfBeW1HvtQneaxO81yZ4r03wXltR77UJ3msTvNcmeK9N8F5bUe+1Cd5rE7zXJnivTfBeW1HvtQneaxO81yZ4r03wXltR77UJ3msTvNcmeK9N8F5bUe+1Cd5rE7zXJnivTfBeW1HvtQneaxO81yZ4r03wXltR77UJ3msTvNcmeK9N8F5bUe+1Cd5rE7zXJnivTfBeW1HvtQneaxO81yZ4r03wXltR77UJ3msTvNcmeK9N8F5bUe+1Cd5rE7zXJnivTfBeW1HvtQneaxO81yZ4r03wXltR77UL3msXvNcueK9d8F77rRc9S4Au6YL32gXvtQveay/qvXbBe+2C99oF77UL3msv6r12wXvtgvfaBe+1C95rL+q9dsF77YL32gXvtQveay/qvXbBe+2C99oF77UL3msv6r12wXvtgvfaBe+1C95rL+q9dsF77YL32gXvtQveay/qvXbBe+2C99oF77UL3msv6r12wXvtgvfaBe+1C95rL+q9dsF77YL32gXvtQveay/qvXbBe+2C99oF77UL3msv6r12wXvtgvfaBe+1C95rL+q9dsF77YL32gXvtQveay/qvXbBe+2C99oF77UL3msv6r12wXvtgvfaBe+1C95rL+q9dsF77YL32gXvtQveay/qvXbBe+2C99oF77UL3msv6r12wXvtgvfaBe+1C95rL+q9dsF77YL32gXvtQveay/qvQ7Bex2C9zoE73UI3uu49aJnCdAlQ/Beh+C9DsF7HUW91yF4r0PwXofgvQ7Bex1FvdcheK9D8F6H4L0OwXsdRb3XIXivQ/Beh+C9DsF7HUW91yF4r0PwXofgvQ7Bex1FvdcheK9D8F6H4L0OwXsdRb3XIXivQ/Beh+C9DsF7HUW91yF4r0PwXofgvQ7Bex1FvdcheK9D8F6H4L0OwXsdRb3XIXivQ/Beh+C9DsF7HUW91yF4r0PwXofgvQ7Bex1FvdcheK9D8F6H4L0OwXsdRb3XIXivQ/Beh+C9DsF7HUW91yF4r0PwXofgvQ7Bex1FvdcheK9D8F6H4L0OwXsdRb3XIXivQ/Beh+C9DsF7HUW91yF4r0PwXofgvQ7Bex1FvdcheK9D8F6H4L0OwXsdRb3XIXivQ/Beh+C9DsF7HUW91yl4r1PwXqfgvU7Be523XvQsAbpkCt7rFLzXKXivs6j3OgXvdQre6xS81yl4r7Oo9zoF73UK3usUvNcpeK+zqPc6Be91Ct7rFLzXKXivs6j3OgXvdQre6xS81yl4r7Oo9zoF73UK3usUvNcpeK+zqPc6Be91Ct7rFLzXKXivs6j3OgXvdQre6xS81yl4r7Oo9zoF73UK3usUvNcpeK+zqPc6Be91Ct7rFLzXKXivs6j3OgXvdQre6xS81yl4r7Oo9zoF73UK3usUvNcpeK+zqPc6Be91Ct7rFLzXKXivs6j3OgXvdQre6xS81yl4r7Oo9zoF73UK3usUvNcpeK+zqPc6Be91Ct7rFLzXKXivs6j3OgXvdQre6xS81yl4r7Oo9zoF73UK3usUvNcpeK+zqPc6Be91Ct7rFLzXKXivs6j3ugTvdQne6xK81yV4r+vWi54lQJcswXtdgve6BO91FfVel+C9LsF7XYL3ugTvdRX1XpfgvS7Be12C97oE73UV9V6X4L0uwXtdgve6BO91FfVel+C9LsF7XYL3ugTvdRX1XpfgvS7Be12C97oE73UV9V6X4L0uwXtdgve6BO91FfVel+C9LsF7XYL3ugTvdRX1XpfgvS7Be12C97oE73UV9V6X4L0uwXtdgve6BO91FfVel+C9LsF7XYL3ugTvdRX1XpfgvS7Be12C97oE73UV9V6X4L0uwXtdgve6BO91FfVel+C9LsF7XYL3ugTvdRX1XpfgvS7Be12C97oE73UV9V6X4L0uwXtdgve6BO91FfVel+C9LsF7XYL3ugTvdRX1XpfgvS7Be12C97oE73UV9V6X4L0uwXtdgve6BO91FfVet+C9bsF73YL3ugXvdd960bME6JIteK9b8F634L3uot7rFrzXLXivW/Bet+C97qLe6xa81y14r1vwXrfgve6i3usWvNcteK9b8F634L3uot7rFrzXLXivW/Bet+C97qLe6xa81y14r1vwXrfgve6i3usWvNcteK9b8F634L3uot7rFrzXLXivW/Bet+C97qLe6xa81y14r1vwXrfgve6i3usWvNcteK9b8F634L3uot7rFrzXLXivW/Bet+C97qLe6xa81y14r1vwXrfgve6i3usWvNcteK9b8F634L3uot7rFrzXLXivW/Bet+C97qLe6xa81y14r1vwXrfgve6i3usWvNcteK9b8F634L3uot7rFrzXLXivW/Bet+C97qLe6xa81y14r1vwXrfgve6i3usWvNcteK9b8F634L3uot7rEbzXI3ivR/Bej+C9nlsvepYAXXIE7/UI3usRvNdT1Hs9gvd6BO/1CN7rEbzXU9R7PYL3egTv9Qje6xG811PUez2C93oE7/UI3usRvNdT1Hs9gvd6BO/1CN7rEbzXU9R7PYL3egTv9Qje6xG811PUez2C93oE7/UI3usRvNdT1Hs9gvd6BO/1CN7rEbzXU9R7PYL3egTv9Qje6xG811PUez2C93oE7/UI3usRvNdT1Hs9gvd6BO/1CN7rEbzXU9R7PYL3egTv9Qje6xG811PUez2C93oE7/UI3usRvNdT1Hs9gvd6BO/1CN7rEbzXU9R7PYL3egTv9Qje6xG811PUez2C93oE7/UI3usRvNdT1Hs9gvd6BO/1CN7rEbzXU9R7PYL3egTv9Qje6xG811PUez2C93oE7/UI3usRvNdT1HuNmwC+XlMCZXJNCaTJNSXQJteUveqBAtTJNSWQJ9eUQJ9cUwKBck1ZtVAE+vWakigUAX+9piQKpSj/em2cKBQBgL2mJApFIGCvKasWioDAXlMShSIwsNeURKEUhWCvjROFIlCw15REoQgY7DVl1UIRONhrSqJQBBD2mpIolKIk7LVxolAEFPaakigUgYW9pqxaKAIMe01JFIpAw15TEoVSFIe9Nk4UisDDXlMShSIAsdeUVQtFIGKvKYlCEZDYa0qiUIoysdfGiUIRoNhrSqJQBCr2mrJqoQhY7DUlUSgCF3tNSRRKUTD22jhRKAIZe01JFIqAxl5TVi0UgY29piQKRYBjrymJQilKx14bJwpFwGOvKYlCEfjYa8qqhSIAsteURKEIhOw1JVEoRRHZa+NEoQiM7DUlUSgCJHtNWbVQBEr2mpIoFAGTvaYkCqUoJ3ttnCgUAZS9piQKRSBlrymLFkoQpmwQpmwQpmwQpmzcetUDRSiUIEzZIEzZIEzZqGrKBmHKBmHKBmHKBmHKRlVTNghTNghTNghTNghTNqqaskGYskGYskGYskGYslHVlA3ClA3ClA3ClA3ClI2qpmwQpmwQpmwQpmwQpmxUNWWDMGWDMGWDMGWDMGWjqikbhCkbhCkbhCkbhCkbVU3ZIEzZIEzZIEzZIEzZqGrKBmHKBmHKBmHKBmHKRlVTNghTNghTNghTNghTNqqaskGYskGYskGYskGYslHVlA3ClA3ClA3ClA3ClI2qpmwQpmwQpmwQpmwQpmxUNWWDMGWDMGWDMGWDMGWjqikbhCkbhCkbhCkbhCkbVU3ZIEzZIEzZIEzZIEzZqGrKBmHKBmHKBmHKBmHKRlVTNghTNghTNghTNghTNqqaskmYskmYskmYskmYsnnrVQ8UoVCSMGWTMGWTMGWzqimbhCmbhCmbhCmbhCmbVU3ZJEzZJEzZJEzZJEzZrGrKJmHKJmHKJmHKJmHKZlVTNglTNglTNglTNglTNquaskmYskmYskmYskmYslnVlE3ClE3ClE3ClE3ClM2qpmwSpmwSpmwSpmwSpmxWNWWTMGWTMGWTMGWTMGWzqimbhCmbhCmbhCmbhCmbVU3ZJEzZJEzZJEzZJEzZrGrKJmHKJmHKJmHKJmHKZlVTNglTNglTNglTNglTNquaskmYskmYskmYskmYslnVlM3Pm7LXP4M/vGnfPt34f97z2b/vP30O4n/ec7345t2r169fff/167cvnn949fbN+/s33u5/+I0voPz35sStjY/LxfrMjOv28DuvyE8vvd/t/nOXP1++fGsPy/fzaPnf+GLEH1v+4cFdsz1ePr58+f3wpKyzHi+ff+7y7YuX3zl/uXb3x7f2N/7z+x9b/uGDusd8vPz48uXXw63dv/7Dmf/H5c+j5/7n69U/nr979fyb1y/vP8n3v/jjmxcPH+zr5Yd//vDwKw8f/R/evX3x8tsf3728PwQ++fzfP+Lt9qyNa9lr6X8B","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"61":{"source":"mod utils;\n\nfn main(\n    voice_embedding: [Field; 256],\n    command_hash: Field,\n    voice_commitment: pub Field,\n    expected_command_hash: pub Field,\n) {\n    let calculated_commitment = utils::hash_embedding(voice_embedding);\n    assert(calculated_commitment == voice_commitment);\n    assert(command_hash == expected_command_hash);\n}\n","path":"/Users/fabiandiaz/personal-repos/voice-wallet/voice_circuit/src/main.nr"},"62":{"source":"use dep::std::hash::pedersen_hash;\n\npub fn hash_embedding(embedding: [Field; 256]) -> Field {\n    let mut hash = pedersen_hash([embedding[0], embedding[1]]);\n    for i in 2..256 {\n        hash = pedersen_hash([hash, embedding[i]]);\n    }\n    hash\n}\n","path":"/Users/fabiandiaz/personal-repos/voice-wallet/voice_circuit/src/utils.nr"}},"names":["main"],"brillig_names":["decompose_hint"]}